# Server Script runs only on Hosted server & not in test mode
# KrunkScript Copyright (C) Yendis Entertainment Pty Ltd
# 

# Role flags. Uses 1 bit each to allow different roles to use different commands
obj roles = {                
	host: 1,
	mod: 1 << 2,
	user: 1 << 3,
	none: 1 << 30 # Shifting 31 bits makes it negative. Can get around this with "(1 << 31) >>> 0" if needed
};
		
obj config = {
	playerRoles: obj[			# List of player names + role. Uses account name. When data storage is implemented, these can be pulled from a database
		{ name: "SLxTnT", role: roles.mod },
		{ name: "SMGWeak", role: roles.mod }
	],
    commands: obj[ 			# List of commands. Has styling for client and added right to left. New commands need to be added to executeCommand and "Commands" section
		# requiredRole requires a player to have that role to use command. 
		# 	- Adding multiple roles
		#		requiredRole: ((num)roles.mod | (num)roles.host | (num)roles.user)
		# minRole: allows anyone with a higher or equal role (lower number) to use command
		# executeOnSelf: allows/disallows command to be called on yourself (default: false)
		# requiredHigherRole: prevents commands to be called on players of the same role or lower (mod can't ban other mods)
		{ name: "TP2", color: "#000079", minRole: roles.mod }, 
		{ name: "TPMe", color: "#000079", minRole: roles.mod },
		{ isSeparator: true, width: 5 }, # Separates buttons
		{ name: "Kick", color: "#a200cf", minRole: roles.mod, requiredHigherRole: true },
		{ name: "Ban", color: "#790000", minRole: roles.mod, requiredHigherRole: true }
	]
};

# Commands

action banPlayer(obj player) {
	GAME.ADMIN.ban((str)player.id);
	
}

action kickPlayer(obj player) {
	GAME.ADMIN.kick((str)player.id);
}

action tpPlayer(obj from, obj to) {
	
	# Position update
	from.position.x = to.position.x;
	from.position.y = to.position.y;
	from.position.z = to.position.z;
	
	# Reset velocity
	from.velocity.x = 0;
	from.velocity.y = 0;
	from.velocity.z = 0;
}

obj action findPlayer(str accountName) {
	obj[] players = GAME.PLAYERS.list();

	for(num i = 0; i < lengthOf players; i++) {
		if((str)players[i].accountName == accountName) {
			return (obj)players[i];
		}
	}

	return {};
}

action sendError(obj player, obj command, str message) {
	GAME.CHAT.send(player.id, message, "#ff0000");

	#GAME.NETWORK.send("commandError", { command: command, error: message }, player.id);
}

action executeCommand(obj command, obj data, obj player, obj targetPlayer) {
	if(!command.executeOnSelf && (str)player.accountName == (str)targetPlayer.accountName)								# Too lazy to check object reference equality
	{
		sendError(player, command, "Cannot target yourself with this command");
		return;
	}

	# Add new commands here
	if((str)command.name == "TP2") {
		tpPlayer(player, targetPlayer);
	}
	else if((str)command.name == "TPMe") {
		tpPlayer(targetPlayer, player);
		
	}
	else if((str)command.name == "Kick") {
		kickPlayer(targetPlayer);
		
	}
	else if((str)command.name == "Ban") {
		banPlayer(targetPlayer);
	}
}

# End Commands

num action getRole(str accountName) {
	for(num i = 0; i < lengthOf config.playerRoles; i++) {
		if((str)config.playerRoles[i].name == accountName) {
			return (num)config.playerRoles[i].role;
		}
	}
	
	return (num)roles.none;
}
 
bool action canUseCommand(obj command, obj player, obj targetPlayer) {
	if(notEmpty targetPlayer && (bool)command.requiredHigherRole && (num)player.role <= (num)targetPlayer.role) {
		return false;
	}
	
	if((toNum command.minRole > 0 && (num)player.role <= (num)command.minRole) || 										# minRole is set AND player role is better or equal to command role min
			toNum command.requiredRole > 0 && ((num)command.requiredRole & (num)player.role) == (num)player.role) { 	# requiredRole is set AND bit flag for player role is set
			 return true;
		}
	
	return false;
}

obj action getCommand(obj commandData) {
	for(num i = 0; i < lengthOf config.commands; i++) {
		if((str)config.commands[i].name == (str)commandData.method) {
			return (obj)config.commands[i];
		}
	}
	
	return {};
}

action handlePlayerSpawn(str id) {
	obj player = GAME.PLAYERS.findByID(id);

	player.role = getRole((str)player.accountName);

	# Send valid buttons to client
	obj[] buttons = obj[];

	for(num i = 0; i < lengthOf config.commands; i++) {
		if(!!config.commands[i].isSeparator && lengthOf buttons > 0) {
			addTo buttons (obj)config.commands[i];
			continue;
		}
		
		if(canUseCommand((obj)config.commands[i], player, {})) {
			addTo buttons (obj)config.commands[i];
		}
	}

	if(lengthOf buttons > 0) {
		GAME.NETWORK.send("commandMenu", { buttons: buttons }, id);
	}
}

action handleNetworkMessage(str id, obj data, str playerID) {
	if(id == "executeCommand") {
		obj command = getCommand(data);

		# Valid command
		if(notEmpty command) {
			obj player = GAME.PLAYERS.findByID(playerID);
			str playerName = toStr data.username;
	
			obj targetPlayer = findPlayer(playerName);

			if(!(notEmpty targetPlayer)) {
				sendError(player, command, "Target player doesn\'t exist");
				return;
			}

			if(canUseCommand(command, player, targetPlayer)) {
				executeCommand(command, data, player, targetPlayer);
			}
			else {
				sendError(player, command, "Invalid role");
			}
		}
	}
}

# Game Hooks

public action onPlayerSpawn(str id) {
	handlePlayerSpawn(id);
}

public action onNetworkMessage(str id, obj data, str playerID) {
	handleNetworkMessage(id, data, playerID);
}
